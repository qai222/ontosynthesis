# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: dataset.proto, reaction.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    Dict,
    List,
    Optional,
)

import betterproto


class ReactionIdentifierType(betterproto.Enum):
    """Possible identifier types are listed in an enum for extensibility"""

    UNSPECIFIED = 0
    CUSTOM = 1
    REACTION_SMILES = 2
    REACTION_CXSMILES = 6
    RDFILE = 3
    RINCHI = 4
    REACTION_TYPE = 5


class AdditionSpeedType(betterproto.Enum):
    UNSPECIFIED = 0
    """Unspecified."""

    ALL_AT_ONCE = 1
    FAST = 2
    SLOW = 3
    DROPWISE = 4
    CONTINUOUS = 5
    PORTIONWISE = 6


class AdditionDeviceType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    NONE = 2
    SYRINGE = 3
    CANNULA = 4
    ADDITION_FUNNEL = 5


class UnmeasuredAmountType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    SATURATED = 2
    """
    Solute species present at saturation limit. Should only be used for
    compounds when a solvent compound is also present in he same input.
    """

    CATALYTIC = 3
    """
    An unmeasured drop or scoop of compound intended to introduce it only at a
    catalytic (very low) concentration.
    """

    TITRATED = 4
    """
    Compound was titrated in, but the actual amount added was not recorded.
    Details of how the amount of compound added was decided, e.g., a change in
    color, should be included in the details field.
    """


class ReactionRoleType(betterproto.Enum):
    UNSPECIFIED = 0
    REACTANT = 1
    """
    A reactant is any compound that contributes atoms to a desired or observed
    product.
    """

    REAGENT = 2
    SOLVENT = 3
    CATALYST = 4
    WORKUP = 5
    """
    The workup role is used when defining quenches, buffer additives for
    liquid-liquid separations, etc.
    """

    INTERNAL_STANDARD = 6
    """
    Internal standards can be included as part of a reaction input (when added
    prior to the start of the reaction) or as part of a workup step of
    addition.
    """

    AUTHENTIC_STANDARD = 7
    PRODUCT = 8
    """
    A product can be any species produced by the reaction, whether desired or
    undesired.
    """

    BYPRODUCT = 9
    """
    When there is one intended chemical equation: - Set
    `is_desired_product=True` to indicate a desired product. - Use BYPRODUCT to
    indicate a chemical species that is an expected result of the reaction but
    is not the product of interest. - Use SIDE_PRODUCT to indicate the product
    of a side reaction. - See https://doi.org/10.1021/op300317g for a
    discussion of these terms.
    """

    SIDE_PRODUCT = 10


class CompoundPreparationType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    NONE = 2
    REPURIFIED = 3
    SPARGED = 4
    DRIED = 5
    SYNTHESIZED = 6


class CompoundIdentifierType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    SMILES = 2
    """Simplified molecular-input line-entry system."""

    INCHI = 3
    """IUPAC International Chemical Identifier."""

    MOLBLOCK = 4
    """Molblock from a MDL Molfile V3000."""

    IUPAC_NAME = 5
    """Chemical name following IUPAC nomenclature recommendations."""

    NAME = 6
    """Any accepted common name, trade name, etc."""

    CAS_NUMBER = 7
    """Chemical Abstracts Service Registry Number (with hyphens)."""

    PUBCHEM_CID = 8
    """PubChem Compound ID number."""

    CHEMSPIDER_ID = 9
    """ChemSpider ID number."""

    CXSMILES = 10
    """ChemAxon extended SMILES"""

    INCHI_KEY = 11
    """IUPAC International Chemical Identifier key"""

    XYZ = 12
    """XYZ molecule file"""

    UNIPROT_ID = 13
    """UniProt ID (for enzymes)"""

    PDB_ID = 14
    """Protein data bank ID (for enzymes)"""

    AMINO_ACID_SEQUENCE = 15
    """Amino acid sequence (for enzymes)."""

    HELM = 16
    """HELM; https://www.pistoiaalliance.org/helm-notation/."""


class VesselType(betterproto.Enum):
    """Vessel type (flask, vial, well-plate, etc.)."""

    UNSPECIFIED = 0
    CUSTOM = 1
    ROUND_BOTTOM_FLASK = 2
    VIAL = 3
    WELL_PLATE = 4
    MICROWAVE_VIAL = 5
    TUBE = 6
    CONTINUOUS_STIRRED_TANK_REACTOR = 7
    PACKED_BED_REACTOR = 8
    NMR_TUBE = 9
    PRESSURE_FLASK = 10
    PRESSURE_REACTOR = 11
    ELECTROCHEMICAL_CELL = 12


class VesselMaterialType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    GLASS = 2
    POLYPROPYLENE = 3
    PLASTIC = 4
    METAL = 5
    QUARTZ = 6


class VesselAttachmentType(betterproto.Enum):
    UNSPECIFIED = 0
    NONE = 1
    CUSTOM = 2
    SEPTUM = 3
    CAP = 4
    MAT = 5
    REFLUX_CONDENSER = 6
    VENT_NEEDLE = 7
    DEAN_STARK = 8
    VACUUM_TUBE = 9
    ADDITION_FUNNEL = 10
    DRYING_TUBE = 11
    ALUMINUM_FOIL = 12
    THERMOCOUPLE = 13
    BALLOON = 14
    GAS_ADAPTER = 15
    PRESSURE_REGULATOR = 16
    RELEASE_VALVE = 17


class VesselPreparationType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    NONE = 2
    OVEN_DRIED = 3
    FLAME_DRIED = 4
    EVACUATED_BACKFILLED = 5
    PURGED = 6


class ReactionEnvironmentType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    FUME_HOOD = 2
    BENCH_TOP = 3
    GLOVE_BOX = 4
    GLOVE_BAG = 5


class TemperatureControlType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    AMBIENT = 2
    OIL_BATH = 3
    WATER_BATH = 4
    SAND_BATH = 5
    ICE_BATH = 6
    DRY_ALUMINUM_PLATE = 7
    MICROWAVE = 8
    DRY_ICE_BATH = 9
    AIR_FAN = 10
    LIQUID_NITROGEN = 11


class TemperatureMeasurementType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    THERMOCOUPLE_INTERNAL = 2
    THERMOCOUPLE_EXTERNAL = 3
    INFRARED = 4


class PressureControlType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    AMBIENT = 2
    SLIGHT_POSITIVE = 3
    SEALED = 4
    PRESSURIZED = 5


class AtmosphereType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    AIR = 2
    NITROGEN = 3
    ARGON = 4
    OXYGEN = 5
    HYDROGEN = 6
    CARBON_MONOXIDE = 7
    CARBON_DIOXIDE = 8
    METHANE = 9
    AMMONIA = 10
    OZONE = 11
    ETHYLENE = 12
    ACETYLENE = 13


class PressureMeasurementType(betterproto.Enum):
    """TODO(ccoley) get input on how to expand this enum, among others"""

    UNSPECIFIED = 0
    CUSTOM = 1
    PRESSURE_TRANSDUCER = 2


class StirringMethodType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    NONE = 2
    STIR_BAR = 3
    OVERHEAD_MIXER = 4
    AGITATION = 5
    BALL_MILLING = 6
    SONICATION = 7


class StirringRateType(betterproto.Enum):
    UNSPECIFIED = 0
    HIGH = 1
    MEDIUM = 2
    LOW = 3


class IlluminationType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    AMBIENT = 2
    DARK = 3
    LED = 4
    HALOGEN_LAMP = 5
    DEUTERIUM_LAMP = 6
    SOLAR_SIMULATOR = 7
    BROAD_SPECTRUM = 8


class ElectrochemistryType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    CONSTANT_CURRENT = 2
    CONSTANT_VOLTAGE = 3


class ElectrochemistryCellType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    DIVIDED_CELL = 2
    UNDIVIDED_CELL = 3


class FlowType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    PLUG_FLOW_REACTOR = 2
    CONTINUOUS_STIRRED_TANK_REACTOR = 3
    PACKED_BED_REACTOR = 4


class TubingType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    STEEL = 2
    COPPER = 3
    PFA = 4
    FEP = 5
    TEFLONAF = 6
    PTFE = 7
    GLASS = 8
    QUARTZ = 9
    SILICON = 10
    PDMS = 11


class ReactionWorkupType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    ADDITION = 2
    """
    Addition (quench, dilution, extraction solvent, internal standard, etc.)
    Specify composition/amount in "input". Often preceded by TEMPERATURE.
    """

    ALIQUOT = 3
    """
    Sampling (by mass of volume) a portion of the mixture, often for dilution
    in a subsequent ADDITION step prior to analysis. The vessel to which the
    aliquot is transferred can be specified in "details".
    """

    TEMPERATURE = 4
    """Change of temperature. Specify conditions in "temperature"."""

    CONCENTRATION = 5
    """
    Concentration step, often using a rotovap. Specify degree in "details" if
    appropriate, e.g., "to half volume".
    """

    EXTRACTION = 6
    """
    Liquid extractions are often preceded by Additions. If there are multiple
    distinct additions prior to an extraction, it is assumed that the kept
    phases are pooled. Specify which phase to keep in "keep_phase".
    """

    FILTRATION = 7
    """
    Filtration (can keep solid or filtrate). Specify which phase to keep in
    "keep phase".
    """

    WASH = 8
    """
    Washing a solid or liquid, keeping the original phase. Specify "input" of
    rinse. Rinses performed in multiple stages should be given multiple workup
    steps
    """

    DRY_IN_VACUUM = 9
    """Dried under vacuum. Specify temperature in "temperature"."""

    DRY_WITH_MATERIAL = 10
    """Dried with chemical additive. Specify chemical additive in "input"."""

    FLASH_CHROMATOGRAPHY = 11
    """
    Purification by flash chromatography. Specify stationary and mobile phases
    (and gradients) in "details". Specify automation in "is_automated".
    """

    OTHER_CHROMATOGRAPHY = 12
    """
    Purification by other prep chromatography (e.g. prep TLC, prep HPLC).
    Specify method, stationary and mobile phases in "details". Specify
    automation in "is_automated".
    """

    SCAVENGING = 13
    """
    Scavenging step (e.g., pass through silica/alumina pad) Specify any
    material additives in "input".
    """

    WAIT = 14
    """Waiting step. Specify "duration"."""

    STIRRING = 15
    """Mixing step. Specify "stirring"""

    PH_ADJUST = 16
    """
    pH adjustments should specify "input" to define species used as well as
    "ph" for target ph
    """

    DISSOLUTION = 17
    """
    Redissolution considered to be a special form of addition. Specify "input"
    """

    DISTILLATION = 18
    """
    Specify temperature in "temperature". Specify pressure and apparatus notes
    in "details".
    """


class TextureType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    POWDER = 2
    CRYSTAL = 3
    OIL = 4
    AMORPHOUS_SOLID = 5
    FOAM = 6
    WAX = 7
    SEMI_SOLID = 8
    SOLID = 9
    LIQUID = 10


class ProductMeasurementType(betterproto.Enum):
    """
    The type of measurement. While each measurement is associated with a
    specific product compound and is cross-referenced to an analysis through
    the analysis_key, there is still ambiguity as to what a measurement truly
    represents. For example, an LCMS analysis can lead to a quantitative YIELD
    if an authentic standard and internal standard are used to obtain a
    calibration curve; sometimes, it is only used to obtain an uncalibrated
    "yield" that is better described as an peak AREA or integrated EIC COUNTS.
    Understanding the fidelity of the approach taken to measure the performance
    of a reaction is important for downstream learning tasks. Note that this
    message is intended to capture product-specific data extracted from an
    analysis. The raw analytical data (e.g., a full NMR spectrum) should be
    defined in an Analysis message. Even analyses of ostensibly pure compounds
    (e.g., HRMS) should have their results defined in the Analysis message
    (with is_of_isolated_species set to True) but with a cross-reference to a
    product via a ProductMessage (e.g., of type IDENTITY for HRMS).
    """

    UNSPECIFIED = 0
    CUSTOM = 1
    IDENTITY = 2
    """
    An identity type indicates that the corresponding analysis was used to
    confirm the identity of the reported product.
    """

    YIELD = 3
    """
    Yields should only be reported as quantitative yields, e.g., measured using
    an isolated weight analysis, quantitative NMR with an internal standard, LC
    peak area with an internal standard and calibration curve obtained using an
    authentic standard.
    """

    SELECTIVITY = 4
    """
    Selectivites include enantiomeric excess/ratios, diastereomeric ratios,
    etc. The detailed type should be specified in selectivity_type.
    """

    PURITY = 5
    """
    The apparent purity of the product mixture accoridng to a specific analysis
    (e.g,. qNMR, LC).
    """

    AREA = 6
    """Integrated peak area, e.g., as in an LC chromatogram."""

    COUNTS = 7
    """
    Raw counts, e.g., as in an EIC or TIC from a MS analysis. If an EIC, the
    m/z ratio(s) should be defined in the details.
    """

    INTENSITY = 8
    """Intensity, e.g., of a TLC spot, ELSD, or GC FID."""

    AMOUNT = 9
    """
    Quantitative amount of this product as defined in the "amount" field,
    usually as a mass.
    """


class MassSpecMeasurementType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    TIC = 2
    TIC_POSITIVE = 3
    TIC_NEGATIVE = 4
    EIC = 5


class SelectivityType(betterproto.Enum):
    UNSPECIFIED = 0
    CUSTOM = 1
    EE = 2
    ER = 3
    DR = 4
    EZ = 5
    ZE = 6


class AnalysisType(betterproto.Enum):
    """TODO(ccoley): Solicit more feedback from experimentalists"""

    UNSPECIFIED = 0
    CUSTOM = 1
    LC = 2
    GC = 3
    IR = 4
    NMR_1H = 5
    NMR_13C = 6
    NMR_OTHER = 7
    MP = 8
    UV = 9
    TLC = 10
    MS = 11
    HRMS = 12
    MSMS = 13
    WEIGHT = 14
    LCMS = 15
    GCMS = 16
    ELSD = 17
    CD = 18
    SFC = 19
    EPR = 20
    XRD = 21
    RAMAN = 22
    ED = 23


class TimeUnit(betterproto.Enum):
    UNSPECIFIED = 0
    DAY = 4
    HOUR = 1
    MINUTE = 2
    SECOND = 3


class MassUnit(betterproto.Enum):
    UNSPECIFIED = 0
    KILOGRAM = 1
    GRAM = 2
    MILLIGRAM = 3
    MICROGRAM = 4


class MolesUnit(betterproto.Enum):
    UNSPECIFIED = 0
    MOLE = 1
    MILLIMOLE = 2
    MICROMOLE = 3
    NANOMOLE = 4


class VolumeUnit(betterproto.Enum):
    UNSPECIFIED = 0
    LITER = 1
    MILLILITER = 2
    MICROLITER = 3
    NANOLITER = 4


class ConcentrationUnit(betterproto.Enum):
    UNSPECIFIED = 0
    MOLAR = 1
    MILLIMOLAR = 2
    MICROMOLAR = 3


class PressureUnit(betterproto.Enum):
    UNSPECIFIED = 0
    BAR = 1
    ATMOSPHERE = 2
    PSI = 3
    KPSI = 4
    PASCAL = 5
    KILOPASCAL = 6
    TORR = 7
    MM_HG = 8


class TemperatureUnit(betterproto.Enum):
    UNSPECIFIED = 0
    CELSIUS = 1
    FAHRENHEIT = 2
    KELVIN = 3


class CurrentUnit(betterproto.Enum):
    UNSPECIFIED = 0
    AMPERE = 1
    MILLIAMPERE = 2


class VoltageUnit(betterproto.Enum):
    UNSPECIFIED = 0
    VOLT = 1
    MILLIVOLT = 2


class LengthUnit(betterproto.Enum):
    UNSPECIFIED = 0
    CENTIMETER = 1
    MILLIMETER = 2
    METER = 3
    INCH = 4
    FOOT = 5


class WavelengthUnit(betterproto.Enum):
    UNSPECIFIED = 0
    NANOMETER = 1
    WAVENUMBER = 2


class FlowRateUnit(betterproto.Enum):
    UNSPECIFIED = 0
    MICROLITER_PER_MINUTE = 1
    MICROLITER_PER_SECOND = 2
    MILLILITER_PER_MINUTE = 3
    MILLILITER_PER_SECOND = 4
    MICROLITER_PER_HOUR = 5


@dataclass(eq=False, repr=False)
class Reaction(betterproto.Message):
    """
    * Throughout this schema, we introduce enums to encourage consistency in
    nomenclature and to avoid unnecessary downstream data processing that would
    otherwise be required to consolidate equivalent entries. However, we do not
    wish to restrict what users are able to specify if their synthesis does not
    fit cleanly into a pre-existing enum field. For that reason, many enums
    contain a CUSTOM field, which must be accompanied by setting the 'details'
    field, where appropriate). NOTE(kearnes): In many places, we deliberately
    violate the style guide for enums by nesting instead of prefixing; this is
    not done lightly. The primary consideration is API consistency and the
    ability to use unqualified strings as enum values. For instance, we want
    'CUSTOM' to be a valid value for all enums that support custom types.
    """

    identifiers: List["ReactionIdentifier"] = betterproto.message_field(1)
    inputs: Dict[str, "ReactionInput"] = betterproto.map_field(
        2, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    List of pure substances or mixtures that were added to the reaction vessel.
    This is a map instead of a repeated field to simplify reaction templating
    through the use of keys. String keys are simple descriptions and are
    present only for convenience.
    """

    setup: "ReactionSetup" = betterproto.message_field(3)
    """
    The reaction setup specifies how the reaction was prepared, e.g., whether
    it was automated, whether it was run in a glove box.
    """

    conditions: "ReactionConditions" = betterproto.message_field(4)
    """
    Reaction conditions predominantly include temperature, stirring, and
    pressure conditions, but also allow specification of flow, photochemistry,
    and electrochemistry conditions.
    """

    notes: "ReactionNotes" = betterproto.message_field(5)
    """Reaction notes largely pertain to safety considerations."""

    observations: List["ReactionObservation"] = betterproto.message_field(6)
    workups: List["ReactionWorkup"] = betterproto.message_field(7)
    """Workup steps are listed in the order they are performed."""

    outcomes: List["ReactionOutcome"] = betterproto.message_field(8)
    """
    Each reaction outcome contains all analyses and confirmed/expected product
    structures at a particular reaction time.
    """

    provenance: "ReactionProvenance" = betterproto.message_field(9)
    """Provenance contains details of the experimenter and record writer."""

    reaction_id: str = betterproto.string_field(10)
    """Official ID for this reaction in the Open Reaction Database."""


@dataclass(eq=False, repr=False)
class ReactionIdentifier(betterproto.Message):
    """
    * Reaction identifiers define descriptions of the overall reaction. While
    we encourage the use of SMILES strings, these do not work well in all
    cases. The <reaction_smiles> field should be able to be derived from the
    information present in the ReactionInput and ReactionOutcome fields of any
    Reaction message.
    """

    type: "ReactionIdentifierType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    value: str = betterproto.string_field(3)
    is_mapped: Optional[bool] = betterproto.bool_field(
        4, optional=True, group="_is_mapped"
    )
    """
    Whether identifier contains atom-to-atom mapping information. When True, we
    encourage users to specify how that mapping was obtained in the details
    field (e.g., manually, using NameRXN, using ChemDraw).
    """


@dataclass(eq=False, repr=False)
class ReactionInput(betterproto.Message):
    """
    * A reaction input is any pure substance, mixture, or solution that is
    added to the reaction vessel. For example, suppose we are adding 3 mL of a
    4 M solution of NaOH in water. We would define one component for the
    solvent and one component for the solute with the correct respective
    amounts. input {   components: {     identifiers: {type: IDENTIFIER_SMILES,
    value: "O"}     identifiers: {type: IDENTIFIER_NAME, value: "water"}
    volume: {value: 3, units: MILLILITER}     volume_includes_solutes: true   }
    components: {     identifiers: {type: IDENTIFIER_SMILES, value:
    "[Na+].[OH-]"}     identifiers: {type: IDENTIFIER_NAME, value: "sodium
    hydroxide"}     moles: {value: 12, units: MILLIMOLES}   } }
    """

    components: List["Compound"] = betterproto.message_field(1)
    """
    A component is any pure species that is added to the reaction, whether as a
    pure substance or in a mixture/solution.
    """

    crude_components: List["CrudeComponent"] = betterproto.message_field(2)
    """
    A crude component refers to a non-purified, non-isolated compound or
    mixture that is produced by a preceding reaction step.
    """

    addition_order: int = betterproto.int32_field(3)
    """
    The addition order is 1-indexed. Inputs with the same addition_order are
    assumed to be added simultaneously. One input with a lower addition_order
    than another was added earlier in the procedure.
    """

    addition_time: "Time" = betterproto.message_field(4)
    """
    When the addition event took place in terms of the reaction time (or, in
    the case of flow chemistry, the residence time).
    """

    addition_speed: "AdditionSpeed" = betterproto.message_field(5)
    """The qualitative rate of addition."""

    addition_duration: "Time" = betterproto.message_field(6)
    """Quantitatively, how long addition took"""

    flow_rate: "FlowRate" = betterproto.message_field(7)
    """For continuous synthesis, we instead specify a flow rate."""

    addition_device: "AdditionDevice" = betterproto.message_field(8)
    """The device used for addition."""

    addition_temperature: "Temperature" = betterproto.message_field(9)
    """
    Specify the temperature of the material being added. E.g., a cooled flask
    of a stock solution to be added at low temperature.
    """


@dataclass(eq=False, repr=False)
class AdditionSpeed(betterproto.Message):
    type: "AdditionSpeedType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Specify, e.g., portion sizes and intervals for PORTIONWISE."""


@dataclass(eq=False, repr=False)
class AdditionDevice(betterproto.Message):
    type: "AdditionDeviceType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Specify, e.g., "gas-tight" for SYRINGE or cannula material."""


@dataclass(eq=False, repr=False)
class Amount(betterproto.Message):
    """
    * The quantitative amount of a Compound used in a particular reaction.
    Compounds added in their pure form should have their value defined by mass,
    moles, or volume. Compounds prepared as solutions should be defined in
    terms of their volume. Compounds prepared on solid supports should define
    the total mass/volume including the support.
    """

    mass: "Mass" = betterproto.message_field(1, group="kind")
    moles: "Moles" = betterproto.message_field(2, group="kind")
    volume: "Volume" = betterproto.message_field(3, group="kind")
    unmeasured: "UnmeasuredAmount" = betterproto.message_field(5, group="kind")
    volume_includes_solutes: Optional[bool] = betterproto.bool_field(
        4, optional=True, group="_volume_includes_solutes"
    )
    """
    Whether the volume measurement refers to the pure substance or to the total
    volume of the reaction input. An example of when this field should be TRUE
    is when stock solutions are prepared by adding solvent to a volumetric
    flask already containing solute(s).
    """


@dataclass(eq=False, repr=False)
class UnmeasuredAmount(betterproto.Message):
    """
    * Compounds may be defined with qualitative amounts in situations where a
    precise quantity is not measured or reported.
    """

    type: "UnmeasuredAmountType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Full description of the unmeasured amount if more details are known."""


@dataclass(eq=False, repr=False)
class CrudeComponent(betterproto.Message):
    """
    * Crude components are used in multi-step or multi-stage reactions (no
    strong distinction is made here) where one synthetic process must be
    described by multiple "Reaction" messages. In these cases, we often carry
    the crude product from one step/stage into the next. This message is only
    to be used when there is not complete isolation of an intermediate
    molecule; if there is complete isolation, then a regular Compound should be
    used with the SYNTHESIED preparation type.
    """

    reaction_id: str = betterproto.string_field(1)
    """
    The ID of the reaction that produced the crude. Note that this ID must be
    defined within the same Dataset; cross-references cannot exist between
    multiple datasets.
    """

    includes_workup: Optional[bool] = betterproto.bool_field(
        2, optional=True, group="_includes_workup"
    )
    """
    Whether that reaction's workup and purification steps were performed prior
    to addition.
    """

    has_derived_amount: Optional[bool] = betterproto.bool_field(
        3, optional=True, group="_has_derived_amount"
    )
    """
    Whether the amount added in this reaction should be inferred from the
    previous step, i.e, if everything was added.
    """

    amount: "Amount" = betterproto.message_field(4)
    """If the entire crude mixture was not used, need to specify an amount."""


@dataclass(eq=False, repr=False)
class Compound(betterproto.Message):
    """
    * A Compound defines both the identity of a pure species and a quantitative
    amount (mass, moles, volume). For compounds used in inputs, details can be
    provided about how it was prepared and from where it was purchased.
    """

    identifiers: List["CompoundIdentifier"] = betterproto.message_field(1)
    """
    Set of identifiers used to uniquely define this compound. Solutions or
    mixed compounds should use the NAME identifier and list all constituent
    compounds in the "components" field.
    """

    amount: "Amount" = betterproto.message_field(2)
    reaction_role: "ReactionRoleType" = betterproto.enum_field(3)
    is_limiting: Optional[bool] = betterproto.bool_field(
        4, optional=True, group="_is_limiting"
    )
    """Whether this species is intended to be a limiting reactant."""

    preparations: List["CompoundPreparation"] = betterproto.message_field(5)
    source: "Source" = betterproto.message_field(6)
    features: Dict[str, "Data"] = betterproto.map_field(
        7, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Compounds can accommodate any number of features. These may include simple
    properties of the compound (e.g., molecular weight), heuristic estimates of
    physical properties (e.g., ClogP), optimized geometries (e.g., through
    DFT), and calculated stereoelectronic descriptors.
    """

    analyses: Dict[str, "Analysis"] = betterproto.map_field(
        8, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Compounds may be assayed for quality control; analytical data should be
    defined in the analyses map.
    """


@dataclass(eq=False, repr=False)
class Source(betterproto.Message):
    vendor: str = betterproto.string_field(1)
    """Name of the vendor or supplier the compound was purchased from."""

    catalog_id: str = betterproto.string_field(2)
    """Compound ID in the vendor database or catalog."""

    lot: str = betterproto.string_field(3)
    """Batch/lot identification."""


@dataclass(eq=False, repr=False)
class ReactionRole(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class CompoundPreparation(betterproto.Message):
    """
    * Compounds may undergo additional preparation before being used in a
    reaction after being received from a supplier or vendor. We encourage the
    use of the 'preparation' enum when possible, even if the description is an
    oversimplification of the full procedure, which can be described in the
    'details' field.
    """

    type: "CompoundPreparationType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Full description of how the received compound was prepared."""

    reaction_id: str = betterproto.string_field(3)
    """
    The ID of the reaction that produced this species. Note that this ID must
    be defined within the same Dataset; cross-references cannot exist between
    multiple datasets. Only to be used with the SYNTHESIZED preparation type.
    The referenced reaction should not merely be the procedure that was
    followed/reproduced, but the *exact* physical experiment.
    """


@dataclass(eq=False, repr=False)
class CompoundIdentifier(betterproto.Message):
    """
    * Compound identifiers uniquely define a single (pure) chemical species.
    While we encourage the use of SMILES strings, these do not work well in all
    cases (e.g., handling tautomerism, axial chirality). Multiple identifiers
    may be specified for a single compound to avoid ambiguity. We discourage
    chemicals from being defined only by a name. For compounds that are
    prepared or isolated as salts, the identifier should include specification
    of which salt.
    """

    type: "CompoundIdentifierType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    value: str = betterproto.string_field(3)
    """
    Value of the compound identifier; certain types (e.g., PUBCHEM_CID) may
    cast the string as an integer for downstream processing and validation.
    """


@dataclass(eq=False, repr=False)
class Vessel(betterproto.Message):
    """
    * The Vessel defines the primary container within which the reaction was
    performed, including the type of vessel, its primary material, any
    preparation steps or vessel attachments, and its volume.
    """

    type: "VesselType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """
    Include details such as "multi-neck" for ROUND_BOTTOM_FLASK, "J. Young" for
    NMR_TUBE, etc.
    """

    material: "VesselMaterial" = betterproto.message_field(3)
    """Vessel material (glass, plastic, etc.)."""

    preparations: List["VesselPreparation"] = betterproto.message_field(4)
    """How the vessel was prepared for the reaction."""

    attachments: List["VesselAttachment"] = betterproto.message_field(5)
    """Vessel attachments (septum, cap, gas adapter, etc.)."""

    volume: "Volume" = betterproto.message_field(6)
    """Size (volume) of the vessel."""

    vessel_id: str = betterproto.string_field(7)
    """Identifier number for a microtiter plate or parallel reactor run."""

    position: str = betterproto.string_field(8)
    """
    If a well-plate was used, the position of the well for this experiment,
    e.g., "A4".
    """

    row: str = betterproto.string_field(9)
    col: str = betterproto.string_field(10)


@dataclass(eq=False, repr=False)
class VesselMaterial(betterproto.Message):
    type: "VesselMaterialType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class VesselAttachment(betterproto.Message):
    type: "VesselAttachmentType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """
    Include attachment specifications, e.g., "rubber" for SEPTUM, "Teflon" for
    CAP, "water jacket" for REFLUX_CONDENSER, etc. Also include sealing
    details, e.g., "electrical tape", "parafilm", etc.
    """


@dataclass(eq=False, repr=False)
class VesselPreparation(betterproto.Message):
    type: "VesselPreparationType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ReactionSetup(betterproto.Message):
    vessel: "Vessel" = betterproto.message_field(1)
    is_automated: Optional[bool] = betterproto.bool_field(
        2, optional=True, group="_is_automated"
    )
    """Specification of automated protocols."""

    automation_platform: str = betterproto.string_field(3)
    """Automated platform name, brand, or model number."""

    automation_code: Dict[str, "Data"] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """Raw automation code or synthetic recipe definition."""

    environment: "ReactionEnvironment" = betterproto.message_field(5)
    """Specify reaction environment."""


@dataclass(eq=False, repr=False)
class ReactionEnvironment(betterproto.Message):
    type: "ReactionEnvironmentType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Specify environment details, e.g., "nitrogen-filled" for GLOVE_BOX."""


@dataclass(eq=False, repr=False)
class ReactionConditions(betterproto.Message):
    temperature: "TemperatureConditions" = betterproto.message_field(1)
    pressure: "PressureConditions" = betterproto.message_field(2)
    stirring: "StirringConditions" = betterproto.message_field(3)
    illumination: "IlluminationConditions" = betterproto.message_field(4)
    electrochemistry: "ElectrochemistryConditions" = betterproto.message_field(5)
    flow: "FlowConditions" = betterproto.message_field(6)
    reflux: Optional[bool] = betterproto.bool_field(7, optional=True, group="_reflux")
    ph: Optional[float] = betterproto.float_field(8, optional=True, group="_ph")
    conditions_are_dynamic: Optional[bool] = betterproto.bool_field(
        9, optional=True, group="_conditions_are_dynamic"
    )
    """
    Boolean to describe whether the conditions cannot be represented by the
    static, single-step schema.
    """

    details: str = betterproto.string_field(10)
    """
    A catch-all string field for providing more information about the
    conditions (e.g., multiple stages)
    """


@dataclass(eq=False, repr=False)
class TemperatureConditions(betterproto.Message):
    control: "TemperatureControl" = betterproto.message_field(1)
    setpoint: "Temperature" = betterproto.message_field(2)
    measurements: List["TemperatureMeasurement"] = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class TemperatureControl(betterproto.Message):
    type: "TemperatureControlType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """
    Specify, e.g., ICE_BATH components (e.g., "ice water, salt"), MICROWAVE
    power, AIR_FAN speed, etc.
    """


@dataclass(eq=False, repr=False)
class TemperatureMeasurement(betterproto.Message):
    type: "TemperatureMeasurementType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    time: "Time" = betterproto.message_field(3)
    temperature: "Temperature" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class PressureConditions(betterproto.Message):
    control: "PressureControl" = betterproto.message_field(1)
    setpoint: "Pressure" = betterproto.message_field(2)
    atmosphere: "Atmosphere" = betterproto.message_field(3)
    measurements: List["PressureMeasurement"] = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class PressureControl(betterproto.Message):
    type: "PressureControlType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Include means of pressure control in "Attachment" when appropriate."""


@dataclass(eq=False, repr=False)
class Atmosphere(betterproto.Message):
    type: "AtmosphereType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class PressureMeasurement(betterproto.Message):
    type: "PressureMeasurementType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    time: "Time" = betterproto.message_field(3)
    pressure: "Pressure" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class StirringConditions(betterproto.Message):
    type: "StirringMethodType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Specify, e.g., "egg-shape" for STIR_BAR."""

    rate: "StirringRate" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class StirringRate(betterproto.Message):
    type: "StirringRateType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Specify, e.g., "vigorous" for HIGH, or specify exact rpm in "rpm"."""

    rpm: int = betterproto.int32_field(3)


@dataclass(eq=False, repr=False)
class IlluminationConditions(betterproto.Message):
    type: "IlluminationType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    peak_wavelength: "Wavelength" = betterproto.message_field(3)
    color: str = betterproto.string_field(4)
    distance_to_vessel: "Length" = betterproto.message_field(5)


@dataclass(eq=False, repr=False)
class ElectrochemistryConditions(betterproto.Message):
    type: "ElectrochemistryType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    current: "Current" = betterproto.message_field(3)
    voltage: "Voltage" = betterproto.message_field(4)
    anode_material: str = betterproto.string_field(5)
    cathode_material: str = betterproto.string_field(6)
    electrode_separation: "Length" = betterproto.message_field(7)
    measurements: List["ElectrochemistryMeasurement"] = betterproto.message_field(8)
    cell: "ElectrochemistryCell" = betterproto.message_field(9)


@dataclass(eq=False, repr=False)
class ElectrochemistryMeasurement(betterproto.Message):
    time: "Time" = betterproto.message_field(1)
    current: "Current" = betterproto.message_field(2)
    voltage: "Voltage" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ElectrochemistryCell(betterproto.Message):
    type: "ElectrochemistryCellType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """
    Include electrochemistry reaction-ware specifications, e.g., home-made vs.
    commercial cell and details.
    """


@dataclass(eq=False, repr=False)
class FlowConditions(betterproto.Message):
    type: "FlowType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    pump_type: str = betterproto.string_field(3)
    tubing: "Tubing" = betterproto.message_field(4)


@dataclass(eq=False, repr=False)
class Tubing(betterproto.Message):
    type: "TubingType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    diameter: "Length" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ReactionNotes(betterproto.Message):
    is_heterogeneous: Optional[bool] = betterproto.bool_field(
        1, optional=True, group="_is_heterogeneous"
    )
    """Equivalent to "not single phase"."""

    forms_precipitate: Optional[bool] = betterproto.bool_field(
        2, optional=True, group="_forms_precipitate"
    )
    """Qualitative precipitation. Could be desired or by-product."""

    is_exothermic: Optional[bool] = betterproto.bool_field(
        3, optional=True, group="_is_exothermic"
    )
    """Qualitative exothermicity (primarily for safety)."""

    offgasses: Optional[bool] = betterproto.bool_field(
        4, optional=True, group="_offgasses"
    )
    """Qualitative offgassing (primarily for safety)."""

    is_sensitive_to_moisture: Optional[bool] = betterproto.bool_field(
        5, optional=True, group="_is_sensitive_to_moisture"
    )
    is_sensitive_to_oxygen: Optional[bool] = betterproto.bool_field(
        6, optional=True, group="_is_sensitive_to_oxygen"
    )
    is_sensitive_to_light: Optional[bool] = betterproto.bool_field(
        7, optional=True, group="_is_sensitive_to_light"
    )
    safety_notes: str = betterproto.string_field(8)
    """
    Include additional sensitivity issues, e.g., shock or heat. Include
    toxicity and other safety warnings.
    """

    procedure_details: str = betterproto.string_field(9)
    """Overflow field for full procedure details"""


@dataclass(eq=False, repr=False)
class ReactionObservation(betterproto.Message):
    time: "Time" = betterproto.message_field(1)
    comment: str = betterproto.string_field(2)
    image: "Data" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class ReactionWorkup(betterproto.Message):
    type: "ReactionWorkupType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """
    Include step-specific details such as purpose of an addition, e.g.,
    "crystallization". Include method details, e.g., "layer diffusion".
    """

    duration: "Time" = betterproto.message_field(3)
    input: "ReactionInput" = betterproto.message_field(4)
    amount: "Amount" = betterproto.message_field(5)
    """
    When aliquotting a portion of the reaction mixture, the amount is specified
    by mass or volume. Note that the amounts for additions should be described
    in the "input" field instead; these are only for aliquots.
    """

    temperature: "TemperatureConditions" = betterproto.message_field(6)
    keep_phase: str = betterproto.string_field(7)
    stirring: "StirringConditions" = betterproto.message_field(8)
    target_ph: Optional[float] = betterproto.float_field(
        9, optional=True, group="_target_ph"
    )
    is_automated: Optional[bool] = betterproto.bool_field(
        10, optional=True, group="_is_automated"
    )
    """
    Indicate automated workup/purification. Include specifications in
    "details", e.g., instrument manufacturer, solvent gradient (if applicable),
    column material and size, etc.
    """


@dataclass(eq=False, repr=False)
class ReactionOutcome(betterproto.Message):
    """
    * The outcomes of a reaction describe the conversion, yield, and/or other
    analyses of the resulting product mixture after workup step(s). Each
    outcome is associated with a reaction/residence time. To allow for one
    Reaction message to contain the results of a full kinetic profiling
    experiment, this is a repeated field of the Reaction message. It is the
    parent message for product characterization and any analytical data.
    """

    reaction_time: "Time" = betterproto.message_field(1)
    """Reaction time (for flow, equivalent to residence time or spacetime)."""

    conversion: "Percentage" = betterproto.message_field(2)
    """
    Conversion with respect to the sole limiting reactant. If there is
    ambiguity in which species the conversion is defined with respect to, the
    quantification of leftover starting materials should be defined as the
    quantification of multiple products, where the compound identity of those
    products matches the starting materials.
    """

    products: List["ProductCompound"] = betterproto.message_field(3)
    """
    The products observed in this reaction, including product-specific data
    defined in submessages. If the quantities of leftover starting materials
    are measured, these starting materials may also be defined as product
    species.
    """

    analyses: Dict[str, "Analysis"] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Analyses are stored in a map to associate each with a unique key. The key
    is cross-referenced in ProductCompound's ProductMeasurement messages to
    indicate which analyses were used to derive which performance
    values/metrics. The string used for the key carries no meaning outside of
    this cross-referencing.
    """


@dataclass(eq=False, repr=False)
class ProductCompound(betterproto.Message):
    identifiers: List["CompoundIdentifier"] = betterproto.message_field(1)
    """The identity of the product compound."""

    is_desired_product: Optional[bool] = betterproto.bool_field(
        2, optional=True, group="_is_desired_product"
    )
    measurements: List["ProductMeasurement"] = betterproto.message_field(3)
    """
    Each ProductMeasurement describes a connection between this product and an
    Analysis. This includes information about how the identity of the product
    was confirmed. It also contains quantitative standardized performance
    metrics like quantitative yield as well as unstandardized (and
    unnormalized) metrics like an integrated UV peak area.
    """

    isolated_color: str = betterproto.string_field(4)
    texture: "Texture" = betterproto.message_field(5)
    features: Dict[str, "Data"] = betterproto.map_field(
        6, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """Any features (e.g., calculated descriptors) of the product compound."""

    reaction_role: "ReactionRoleType" = betterproto.enum_field(7)
    """
    Specify the role the ProductCompound played in the reaction. This aids in
    constructing proper reaction SMILES and product lists. Species produced by
    the reaction should be identified as PRODUCT, whether desired or undesired.
    Recovered starting materials can be specified as REACTANT, REAGENT,
    CATALYST, etc. as appropriate.
    """


@dataclass(eq=False, repr=False)
class Texture(betterproto.Message):
    type: "TextureType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """
    Specify texture forms such as "fine needles" for CRYSTAL, "viscous" for
    OIL, etc.
    """


@dataclass(eq=False, repr=False)
class ProductMeasurement(betterproto.Message):
    analysis_key: str = betterproto.string_field(1)
    """
    The key of the analysis used to calculate this product-specific
    measurement; this should cross-reference the outcome.analyses map.
    """

    type: "ProductMeasurementType" = betterproto.enum_field(2)
    details: str = betterproto.string_field(3)
    """
    Additional information about the measurement and, in particular, how it was
    calculated if that is ambiguous given the analysis type.
    """

    uses_internal_standard: Optional[bool] = betterproto.bool_field(
        4, optional=True, group="_uses_internal_standard"
    )
    """
    Whether an internal standard was used for this measurement to normalize it,
    e.g., for quantification of yield or relative peak area.
    """

    is_normalized: Optional[bool] = betterproto.bool_field(
        5, optional=True, group="_is_normalized"
    )
    """
    Whether the reported measurement has already been normalized to the
    internal standard, if an internal standard was used.
    """

    uses_authentic_standard: Optional[bool] = betterproto.bool_field(
        6, optional=True, group="_uses_authentic_standard"
    )
    """
    Whether an authentic sample of a material was used for callibrating an
    analytical technique, e.g., for product identification by LCMS. "Authentic"
    refers to a sample of a compound whose structure has been proven by the
    accepted means (1H NMR, 13C NMR, IR, HRMS), and is now being used as a
    comparison for other analytical methods.
    """

    authentic_standard: "Compound" = betterproto.message_field(7)
    """
    Details about the authentic standard used, optionally including information
    about its precise salt form and source/vendor.
    """

    percentage: "Percentage" = betterproto.message_field(8, group="value")
    """
    A percentage value and its precision, as should be used for yields,
    purities, and some selectivities like EE. Note that a 50% yield corresponds
    to a percentage.value of 50 and not 0.5.
    """

    float_value: "FloatValue" = betterproto.message_field(9, group="value")
    """
    A float value and its precision, as should be used for areas, counts,
    intensities, and some selectivities.
    """

    string_value: str = betterproto.string_field(10, group="value")
    """
    A string value, as should be used for measurements that cannot be captured
    as floats or percentages. For example, complex selectivities such as
    "2:1:1". Note that in the case of a 2:1:1 selectivity, however, it is
    preferable to define the 3 distinct products specifically and record the 3
    product-specific measurements (e.g., peak areas) that were used to derive
    the "2:1:1" summary statistic.
    """

    amount: "Amount" = betterproto.message_field(11, group="value")
    """
    Quantitative amount of this product. Measurements of this type should be
    linked to an analysis of type WEIGHT. Separate ProductMeasurement entries
    should be used to capture multiple amounts, such as mass and moles.
    However, since moles is derived from mass, recording just the mass is fine.
    """

    retention_time: "Time" = betterproto.message_field(12)
    """
    A time to be used only when specifying the retention time at which a peak
    area or intensity was calculated, e.g., as in LC, LCMS, GC, or GCMS.
    """

    mass_spec_details: "MassSpecMeasurementDetails" = betterproto.message_field(13)
    selectivity: "Selectivity" = betterproto.message_field(14)
    wavelength: "Wavelength" = betterproto.message_field(15)
    """The wavelength used for e.g. LC quantification."""


@dataclass(eq=False, repr=False)
class MassSpecMeasurementDetails(betterproto.Message):
    """
    More details about how a particular performance metric (e.g., counts) was
    calculated from an analysis using mass spec. This includes distinguishing
    total ion current (TIC) counts from extracted ion chromatogram (EIC) counts
    and their corresponding mass ranges or masses.
    """

    type: "MassSpecMeasurementType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    tic_minimum_mz: Optional[float] = betterproto.float_field(
        3, optional=True, group="_tic_minimum_mz"
    )
    """
    The lower bound of the m/z interval used to calculate the TIC counts.
    """

    tic_maximum_mz: Optional[float] = betterproto.float_field(
        4, optional=True, group="_tic_maximum_mz"
    )
    """
    The upper bound of the m/z interval used to calculate the TIC counts.
    """

    eic_masses: List[float] = betterproto.float_field(5)
    """
    A list of m/z ratios that were used to calculate the peak area or intensity
    from an extracted ion chromatogram (EIC), e.g., from an LCMS analysis.
    """


@dataclass(eq=False, repr=False)
class Selectivity(betterproto.Message):
    """
    The more specific type of selectivity that is being reported, e.g., EE, ER,
    DR, EZ, ZE. EZ, ER, and DR assume that any product labeled as desired is
    first in the calculation, whereas EZ and ZE ratios are calculated as
    written. Only to be used when the type is SELECTIVITY.
    """

    type: "SelectivityType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DateTime(betterproto.Message):
    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Analysis(betterproto.Message):
    type: "AnalysisType" = betterproto.enum_field(1)
    details: str = betterproto.string_field(2)
    """Any details about analysis (e.g., NMR type, columns, gradients)."""

    chmo_id: int = betterproto.int32_field(3)
    """
    Whether this analysis is intended to be of an isolated species. If false
    RSC Chemical Methods Ontology ID to define the analytical method with
    greater specificity. Defined at https://github.com/rsc-ontologies/rsc-cmo.
    """

    is_of_isolated_species: Optional[bool] = betterproto.bool_field(
        4, optional=True, group="_is_of_isolated_species"
    )
    """
    or unspecified, the assumption is that it is of a crude product mixture (or
    a partially worked-up product mixture).
    """

    data: Dict[str, "Data"] = betterproto.map_field(
        5, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """Data values or files (raw, processed, or annotated)."""

    instrument_manufacturer: str = betterproto.string_field(6)
    instrument_last_calibrated: "DateTime" = betterproto.message_field(7)


@dataclass(eq=False, repr=False)
class ReactionProvenance(betterproto.Message):
    experimenter: "Person" = betterproto.message_field(1)
    city: str = betterproto.string_field(2)
    experiment_start: "DateTime" = betterproto.message_field(3)
    doi: str = betterproto.string_field(4)
    patent: str = betterproto.string_field(5)
    publication_url: str = betterproto.string_field(6)
    record_created: "RecordEvent" = betterproto.message_field(7)
    record_modified: List["RecordEvent"] = betterproto.message_field(8)
    reaction_metadata: Dict[str, "Data"] = betterproto.map_field(
        9, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
    """
    Container for arbitrary reaction metadata; e.g., an internal project
    identifier.
    """

    is_mined: Optional[bool] = betterproto.bool_field(
        10, optional=True, group="_is_mined"
    )
    """
    Set to true for programmatically extracted data; e.g., text mining from
    patents. Set to false for manually curated data or template enumeration
    from structured data (like a spreadsheet).
    """


@dataclass(eq=False, repr=False)
class Person(betterproto.Message):
    username: str = betterproto.string_field(1)
    name: str = betterproto.string_field(2)
    orcid: str = betterproto.string_field(3)
    organization: str = betterproto.string_field(4)
    email: str = betterproto.string_field(5)


@dataclass(eq=False, repr=False)
class RecordEvent(betterproto.Message):
    time: "DateTime" = betterproto.message_field(1)
    person: "Person" = betterproto.message_field(2)
    details: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class Time(betterproto.Message):
    """
    * To allow users to describe synthetic processes in whatever units they
    find most natural, we define a fixed list of allowable units for each
    measurement type. Upon submission to a centralized database, or using a
    validation and canonicalization script, we will convert all values to the
    default units (the first nonzero item in each enum). Each message also
    contains a `precision` field, which specifies the precision of the
    measurement in the same units as the measurement itself. Often the
    precision will be the standard deviation from an instrument calibration.
    """

    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "TimeUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Mass(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "MassUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Moles(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "MolesUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Volume(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "VolumeUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Concentration(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "ConcentrationUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Pressure(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "PressureUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Temperature(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "TemperatureUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Current(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "CurrentUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Voltage(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "VoltageUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Length(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "LengthUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Wavelength(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "WavelengthUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class FlowRate(betterproto.Message):
    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""

    units: "FlowRateUnit" = betterproto.enum_field(3)


@dataclass(eq=False, repr=False)
class Percentage(betterproto.Message):
    """Used for things like conversion and yield."""

    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""


@dataclass(eq=False, repr=False)
class FloatValue(betterproto.Message):
    """Wrapper for floats to include a precision."""

    value: Optional[float] = betterproto.float_field(1, optional=True, group="_value")
    precision: Optional[float] = betterproto.float_field(
        2, optional=True, group="_precision"
    )
    """Precision of the measurement (with the same units as `value`)."""


@dataclass(eq=False, repr=False)
class Data(betterproto.Message):
    """Data is a container for arbitrary data."""

    float_value: float = betterproto.float_field(1, group="kind")
    integer_value: int = betterproto.int32_field(2, group="kind")
    bytes_value: bytes = betterproto.bytes_field(3, group="kind")
    string_value: str = betterproto.string_field(4, group="kind")
    url: str = betterproto.string_field(5, group="kind")
    description: str = betterproto.string_field(6)
    """Description of these data (but avoid redundancy with map keys)."""

    format: str = betterproto.string_field(7)
    """
    Description of the file format (if applicable); usually the file extension.
    For example, 'png' or 'tiff' for images. If empty, we assume string data.
    """


@dataclass(eq=False, repr=False)
class Dataset(betterproto.Message):
    """
    A Dataset is a collection of Reaction message that is used to group
    reactions together into a logical unit along with relevant metadata or
    scripts for understanding and using the data.
    """

    name: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    reactions: List["Reaction"] = betterproto.message_field(3)
    """
    The Dataset is specified by either:   * a list of Reactions   * a list of
    Reaction IDs from existing datasets Note that these are mutually exclusive.
    List of Reaction messages that are part of this dataset.
    """

    reaction_ids: List[str] = betterproto.string_field(4)
    """
    List of Reaction IDs that are part of this dataset. This is designed for
    creating Datasets that are composed of subsets of Reactions from existing
    datasets. For example, a collection of all reactions of a certain type
    across multiple datasets.
    """

    dataset_id: str = betterproto.string_field(5)
    """Dataset ID assigned during the submission process."""


@dataclass(eq=False, repr=False)
class DatasetExample(betterproto.Message):
    """
    Metadata for an example of using a Dataset. For example, a DatasetExample
    might include a URL for a colab/jupyter notebook or a blog post showing how
    to use the Dataset in a downstream machine learning application.
    """

    dataset_id: str = betterproto.string_field(1)
    description: str = betterproto.string_field(2)
    url: str = betterproto.string_field(3)
    created: "RecordEvent" = betterproto.message_field(4)
